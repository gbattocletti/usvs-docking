import numpy as np

from seacat_dp.model import hydrodynamics, wind_dynamics
from seacat_dp.model.model import USVModel
from seacat_dp.model.parameters_seadragon import SeaDragonParameters
from seacat_dp.utils.transformations import R_b2i


class SeaDragonModel(USVModel):
    """
    Nonlinear 2D dynamic model of the SeaDragon vessel.

    The state vector is defined as a (6, ) vector:
    q (np.ndarray): [x, y, theta, u_x, u_y, omega]

    where:
        x (float): position along x axis (inertial frame)
        y (float): position along y axis (inertial frame)
        theta (float): orientation (angle between body frame and inertial frame)
        u_x (float): velocity along x axis (body frame)
        u_y (float): velocity along y axis (body frame)
        omega (float): angular velocity (derivative of theta)

    The control input is defined as a (4, ) vector:
    u (np.ndarray): [f_l, f_r, alpha_l, alpha_r]

    where:
        f_l (float): left thruster force
        f_r (float): right thruster force
        alpha_l (float): left thruster angle
        alpha_r (float): right thruster angle

    Since the thrusters have a dynamics of their own, the force and angle at a given
    time are technically also part of the state vector.

    Each instance of the class holds a copy of the USV parameters, which can be modified
    to create a model with model mismatch. The parameters are imported from the
    `SeaDragonParameters` class in the `seadragon_pars.py` module.
    """

    def __init__(self, pars: SeaDragonParameters):
        """
        Initializes the SeaDragon model.

        Args:
            pars (SeaDragonParameters): instance of the SeaDragonParameters class
                containing the parameters for the model.
        """
        super().__init__(pars)

        # Initialize SeaDragon control input
        self.u = np.zeros(4)  # force vector [f_l, f_r, alpha_l, alpha_r]

    def dynamics(
        self,
        q: np.ndarray,
        u: np.ndarray,
        v_current: np.ndarray,
        v_wind: np.ndarray,
        use_nonlinear_dynamics: bool = False,
    ) -> np.ndarray:
        """
        ODEs of the 2D nonlinear point-mass model of the SeaDragon.

        Args:
            q (np.ndarray): (6, ) state vector (see `step` method for more details).
            u (np.ndarray): (4, ) control input (real actuator inputs computed from the
            thrusters dynamics) (see `step` method for more details).
            v_current (np.ndarray): (3, ) water current speed expressed in the inertial
            frame (see `step` method for more details).
            v_wind (np.ndarray): (3, ) wind speed expressed in the inertial frame (see
            `step` method for more details).

        Returns:
            q_dot (np.ndarray): (6, ) time derivative of the state vector.
        """
        # Coriolis matrix update
        if use_nonlinear_dynamics is True:
            self.C[2, 0] = (self.m + self.Y_vdot) * q[4] + (
                self.m_xg + self.Y_rdot
            ) * q[5]
            self.C[2, 1] = -(self.m + self.X_udot) * q[3]
            self.C[0, 2] = -self.C[2, 0]
            self.C[1, 2] = -self.C[2, 1]

            # Nonlinear damping matrix update
            self.D_NL[2, 2] = 10 * self.Nr * np.abs(q[5])  # Fossen NL damping estimate
        else:
            self.C[:, :] = 0.0
            self.D_NL[:, :] = 0.0
        D = self.D_L + self.D_NL  # pack damping matrices in a single (3, 3) matrix

        # Compute the exogenous inputs in the local (body) reference frame
        b_current = hydrodynamics.crossflow_drag(self.q, self.pars, v_current)  # (3, )
        b_wind = wind_dynamics.wind_load(self.q, v_wind)  # wind load (3, )

        # Compute force generated by the thrusters in their current configuration
        f = self.force_azimuth_thrusters(u)

        # Dynamic equations
        v = q[3:6]  # velocity vector [u_x, u_y, omega]
        x_dot = R_b2i(q[2]) @ v[0:3]
        v_dot = self.M_inv @ (-D @ v - self.C @ v + f + b_current + b_wind)

        # Output state derivative
        q_dot = np.concat([x_dot, v_dot])
        return q_dot

    def force_azimuth_thrusters(self, u: np.ndarray) -> np.ndarray:
        """
        Computes the force generated by the azimuth thrusters based on the control
        input, i.e., the current RPM and angle of the thrusters.

        Args:
            u (np.ndarray): (4, ) control input vector [f_l, f_r, alpha_l, alpha_r].
            NOTE:   alpha_l and alpha_r increase clockwise, i.e., 0 is the positive
                    x-axis and pi/2 is the positive y-axis. This means that a positive
                    f_l for alpha_l = 0 will generate a force in the positive
                    x direction.

        Returns:
            f (np.ndarray): (3, ) force vector generated by the thrusters applied to
            the USV center of mass and expressed in the body frame.
        """
        # Validate input
        if u.shape != (4,):
            raise ValueError("u must be a (4, ) vector.")

        # Extract forces and angles from the control input
        f_l = u[0]
        f_r = u[1]
        alpha_l = u[2]
        alpha_r = u[3]

        # Compute forces in the body frame
        force_l = np.array(
            [
                f_l * np.cos(alpha_l),
                f_l * np.sin(alpha_l),
                f_l
                * (
                    np.cos(alpha_l) * self.pars.b_thrusters
                    - f_l * np.sin(alpha_l) * self.pars.l_thrusters
                ),
            ]
        )
        force_r = np.array(
            [
                f_r * np.cos(alpha_r),
                f_r * np.sin(alpha_r),
                -f_r
                * (
                    np.cos(alpha_r) * self.pars.b_thrusters
                    + f_r * np.sin(alpha_r) * self.pars.l_thrusters
                ),
            ]
        )

        # Total force in the body frame
        return force_l + force_r

    def thrusters_dynamics(self, u: np.ndarray, u_input: np.ndarray) -> np.ndarray:
        """
        ODEs of the dynamics of the SeaDragon thrusters.

        Args:
            u (np.ndarray): current control input vector
            u_input (np.ndarray): new control input vector

        Returns:
            u_dot (np.ndarray): (4, ) time derivative of the control input vector
        """
        # Validate input
        if u.shape != (4,) or u_input.shape != (4,):
            raise ValueError("f and u must be (4, ) vectors.")

        # Thrusters force dynamics (actuation delay 1st order system)
        delta_force_l = (u_input[0] - u[0]) / self.pars.delay_thrusters
        delta_force_r = (u_input[1] - u[1]) / self.pars.delay_thrusters

        # Angle dynamics
        delta_alpha_l = np.clip(
            u_input[2] - u[2],
            -self.pars.max_thrust_angular_speed,
            self.pars.max_thrust_angular_speed,
        )
        delta_alpha_r = np.clip(
            u_input[3] - u[3],
            -self.pars.max_thrust_angular_speed,
            self.pars.max_thrust_angular_speed,
        )

        u_dot = np.array([delta_force_l, delta_force_r, delta_alpha_l, delta_alpha_r])
        return u_dot

    def thrusters_saturation(self, u: np.ndarray) -> np.ndarray:
        """
        Saturates the thrusters forces. The maximum force of the stern thrusters is a
        function of the USV speed.

        Args:
            u (np.ndarray): control input vector

        Returns:
            u (np.ndarray): saturated control input vector
        """

        # Validate input
        if u.shape != (4,) or u.shape != (4,):
            raise ValueError("f and u must be (4, ) vectors.")

        # Clip thrusters forces
        u[0] = np.clip(u[0], -self.pars.max_thrust, self.pars.max_thrust)
        u[1] = np.clip(u[1], -self.pars.max_thrust, self.pars.max_thrust)

        # Clip thrusters angle to be in the range (-pi, pi]
        u[2] = (u[2] + np.pi) % (2 * np.pi) - np.pi
        u[3] = (u[3] + np.pi) % (2 * np.pi) - np.pi

        return u
